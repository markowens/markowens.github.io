- So, here we are at my shell again.
We have our terminal open.
Let's start our Python filters live coding session
by remembering what we have done last time.
Remember, we had the file fruits.txt
in this directory.
We wanted to count the number of unique fruit names in it.
We said
uniq
fruits-sorted.txt
and we piped it into
fruits-unique.txt.
Just like this.
So, we redirected the unique fruit names
in the output of the unique command to a text file
called fruit-unique.txt.
We then used this text file
with the wc command, word count command,
with the minus l option
to count the number of lines in the new file.
Why?
Because number of lines will give us the number of fruits
as each line is a unique fruit name.
If I actually show the contents of this file,
we see that each line is a unique fruit name.
I can say wc minus l
fruits-unique.txt,
or actually it's fruits-unique.txt not fruits.
We can see that six is the number
of unique fruit names in it.
What you probably have noticed about this command
is that we had to save the results
of the unique command to an extra file
just to count the fruits.
Could we do better?
The answer is yes,
if we take advantage of the pipes and filters
that we just talked about.
We could have just used unique fruits-sorted.txt
and piped into wc minus l.
Let's try that.
Uniq
fruits-sorted.txt
and I pipe it into the second command
we wanted to get,
wc minus l
and we get that six beautifully as the number
of fruits in it.
Actually,
we could have done even better.
We didn't even need to have fruits-sorted.txt.
We could have just typed,
remember that original fruits file,
let's cat that,
fruits.txt.
It had all these names of fruits in it.
We could have just said sort fruits.txt
and piped that into uniq as a command.
That uniq will take the output of sort fruits.txt.
What will that output will be?
It will be this,
right, sorted names
and the uniq will pick the unique attributes in it,
so we can pipe that into uniq
and it's going to give us the number of unique fruits.
Then we can take that and pipe it into wc minus l,
and notice we get that same answer.
We get that same result faster and more efficiently.
And do you notice how short this one command is
compared to all other commands
I typed to get to the same result?
This is one of the features
that makes Unix so powerful
as we described in our first Unix video.
Now, let's look into one more filter command
using man and grep commands.
As I mentioned,
man is the manual page command in Unix.
If I say man cat
I'm gonna get the manual page
for the cat command.
If you look at this manual page,
you'll notice that file
is one of the words
that I use many times
but exactly how many times?
Right, we are trying to count it in this example.
I can actually say man cat
and use grep
to look for that pattern for the word file in it
for a string,
so I can pipe it into grep
and find every line
in that manual page
that has the word file in it.
So, here we see
quite a few lines that has the word file mentioned
within that manual page.
Now, I can take that
and pipe it into our wc command
where it can't command with the only lines option,
and I'll see that 10 lines in that manual page
mention the word file.
So, let's move on.
Let's clear this.
Lastly, let's look at a pipe and filter
that shows what processes are running in my Unix system.
A command that we haven't done before.
Ps is a command for reporting process status,
that stands for process status, ps, in Unix.
We will use ps to show all processes associated
with all the terminals.
So, to do that I actually use some of the ps options.
So, if I say just ps,
I'll see that I have just a few commands
running through here
but if I say ps minus aef
I get like every
process associated with all the terminals running my system,
my Unix-based system actually.
We see that the output is quite a bit.
There's a lot of processes.
It doesn't even fit in my terminal window.
Now, let's add the more command to it
to see what's going on here a little better.
To do that I'm gonna actually
maybe reduce my font size a little bit
to show you more of what's there.
Let's do ps minus aef more.
So, I can make this a little bit more.
Now I'll see all these processes.
As you see on top,
there's UID, PID, PPID.
These are different identifiers associated to processes.
Some of them are the parent process,
some of them are unique ID for the current process
that running in the Unix system,
some of them are actually there
to actually launch our terminal
and some of our Unix core functionality.
That belongs to the system and our kernel.
But if you
go through this
you'll notice that
that first line on the UIDs is not really sorted
and we maybe want to sort that
using our sort command, right?
Let's make a pipe
to sort the result of the ps command
but this time we'll add a redirection
to save the results so far sorting filtering command, right?
If I just said
ps aef sorted
and maybe I'm gonna pipe that into more,
so I could see now that they're all sorted,
as you see here,
including that first header line, oops.
It's still in my terminal
and maybe I want to process that file later
to understand some of these commands.
So, I can instead of more
I can just say
redirect this into out.txt.
Now, out.txt will have the data in a form
I would like to use it.
I was able to in a way quickly prepare data
for further analysis.
One thing I'd like to mention here
is we have the pipe into the sort command as you've seen,
and we have the filter
as the sort command
that processes and does something with this output
of the ps command.
So, ps command piped into a filter
just happens to be the sort command,
but there's a redirector.
Remember,
we've piped into commands,
some of them are filter commands,
some of them are just regular commands
that don't do anything with this input
and we redirect into files,
like out.txt is a file
and we redirect the output of sort
that would normally go into standard out
into a file called out.txt.
After this quick introduction to Python filters,
in the next video let's focus on some filter commands
and other Unix utilities we can leverage
for a quick exploratory data analysis
just like we started here
by converting the results of ps
and saving it into a file, out.txt,
the sorted version of those
for further data analysis.